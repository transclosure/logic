"Timestamp","After looking at counterexamples to the completeness assertion, describe the general problem with the specification causing the completeness check to fail.","In plain English, how would you fix the problem so that the specification passes the completeness check. (Please do not try to implement your fix then re-run the check. We want your raw impression.)","Complete the following alloy fact to fix the problem, causing the completeness check to pass. (Please do not try adding this fact and re-running the check. We want your raw impression.)","Please upload your Amalgam .log file (should be saved in the same location as your .als file)"
"2017/02/21 6:56:24 PM EST","The HeapCells can reference each other, causing cycles that are independent of the Stack","I would do something like the following:
","fact fix { all s : State | all m : HeapCell | m not in m.^(s.references)}","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0BwxpBzOrTYBjTmJsai11b0IwM1E"
"2017/02/21 7:02:55 PM EST","ref counting only specifies that it has incoming edges, This causes there to be disconnected subgraphs","I think ref count should check for incoming edges iff they are along a path from the Stack, i.e. reachable ","","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B49zcTZju8YbOXpycUpmWldTdUE"
"2017/02/21 7:08:34 PM EST","The problem with the specification is that between State A and State B, we can remove a reference from the stack to a certain cell c, but add a reference from c to itself. From State B to State C, we therefore have to keep cell c in the list of allocated cells because it is still being referenced, but not being referenced from the stack.","No self references?","m not in state.references[m]","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0ByEFkF7J4ZePVmF4YlRxNGpHVlk"
"2017/02/21 7:17:31 PM EST","Memory can be self referential, not reachable from the stack, which is a problem","Make sure that memory cannot reference itself/make sure that there can be no memory loops","m not in m.^(state.references)","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B3p6mSLy0S-sS0k0Q1NOU0RvWGc"
"2017/02/21 7:19:03 PM EST","If the stack loses transitive reference to a HeapCell x, that means the HeapCell x should be deallocated (since any cells referencing x should be deallocated as well by transitivity).  This is not captured by the spec because this cell x may have a non zero reference count","I would add a check to make sure that all HeapCell instances NOT reachable from the stack are also removed.  I'm sorry but I implemented this before the survey thinking that it was part of the lab","fact fix { all s : State | all m : HeapCell | reachFromStack[m, s] iff m in s.allocated }","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B0rGLk0FAgxbcFp6bURVT1RYa0k"
"2017/02/21 7:31:24 PM EST","","","",""
"2017/02/21 7:34:03 PM EST","","","",""
"2017/02/21 7:35:07 PM EST","In every case there is a heap cell pointing to itself, which technically doesn't change the references (the same heap cells are being referenced), but the heap origin of the reference changes."," I would not allow self loops in references (so a heap cell can't point to itself).","fact fix {all s: State | all m : HeapCell| all mem: [mem]s.references not = m}","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0BxbqTOKgmwZbeEttSVVoNVJ0SGs"
"2017/02/21 7:35:50 PM EST","For heapcells with self-loops, the ref_count doesn't hit 0, so even though the heapcell is not reachable from Stack, it isn't garbage collected appropriately.","I would modify references so self-loops wouldn't be possible.","no m in s.references[m]","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0By7TCZVThd9gdGpiclhNV3JvMzA"
"2017/02/21 7:39:37 PM EST","Cycles or references","Disallow cycles of references","m->m not in ^(s.references)",""
"2017/02/22 6:39:21 PM EST","Cyclic references don't seem to dereference themselves, causing our memory to never be properly collected. That is, if a memory cell references itself, its reference count never reaches 0.","Hire whoever made Java's garbage collector.

Seriously though, we would need to add on a check for cycles within our references, and allow our GC to collect anything that either has zero references or is not reachable from the stack and is part of a cycle (of element which are also no reachable from the stack).","m->m not in s.references",""
"2017/02/22 6:39:21 PM EST","Cyclic references don't seem to dereference themselves, causing our memory to never be properly collected. That is, if a memory cell references itself, its reference count never reaches 0.","Hire whoever made Java's garbage collector.

Seriously though, we would need to add on a check for cycles within our references, and allow our GC to collect anything that either has zero references or is not reachable from the stack and is part of a cycle (of element which are also no reachable from the stack).","m->m not in s.references",""
"2017/02/22 6:56:05 PM EST","A memory cell can reference itself","Prohibit self-referencing in the spec","fact fix { all s: State | all m: HeapCell | not m->m in s.references }","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B1az1kKAQlJiRGRPbzAzRDV6RkU"
"2017/02/22 7:00:35 PM EST","The Stack stops pointing to things that are allocated","relations between stack and allocated mem should be preserved from A to B","Stack.(StateA.allocated) in Stack.(StateB.allocated)","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B7VGtnqixyJ-TDllME1kR0dHZm8"
"2017/02/22 7:01:00 PM EST","Some memory cells reference themselves, so they can persist even if edges from other memory cells are removed. They won't be deallocated, but can not be reached form the stack, so they cause StateC to be unclean.","Prohibit self loops.","m -> m not in s.references","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B4_rzESutFqXdHY2Z0NWdFFjZk0"
"2017/02/22 7:01:40 PM EST","The completeness check was failing because of self loops and cycles. It was also failing due to having memory cells being referenced to that were not allocated.","I would fix this problem by implementing a fact to prevent self loops and cycles. Regarding the other failure, this was a typo in clean that misevaluated the cleanliness of State A (all s : State.allocated | s in Stack.^(state.references)) vs (all s : state.allocated | s in Stack.^(state.references))","","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B-caXaS7ZMNeb0FwbDE5TGxuYWs"
"2017/02/22 7:04:41 PM EST","If a HeapCell is pointing to itself, its ref count isn't 0, so it's not being deallocated in state c. Similarly, any 2 heapcells that aren't pointed at by the stack , but are by each other, won't be deallocated","I would make it so we only count references that originate with the stack.","m not in s.^(state-m)","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B_d1gPDvdvxmWWR3eDF3ZUFDVkU"
"2017/02/22 7:04:42 PM EST","Since we do not prohibit allocated cells from being de-referenced in the transition from StateA to StateB, they can become de-referenced before they are dellocated and the transition from A to B is not complete.","I would add a condition to the A_to_B fact which prevents the de-referencing of any cells which are allocated in A.","fact fix { all s : State | all m : HeapCell | m in s.allocated implies reachFromStack[m, s]}","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B-GgeE9l48pXaC0wVmxlSjItZnM"
"2017/02/22 7:11:02 PM EST","References can change such that allocated blocks will no longer be reachable from the stack.","This is a reference problem, since we have already deallocated and allocated correctly with regard to reference counts. We should make sure that if something can be reached from the stack and is allocated, that remains unchanged.","fact fix { all s : State | all m : HeapCell | reachFromStack[m,s}",""
"2017/02/22 7:11:57 PM EST","References can change such that allocated blocks will no longer be reachable from the stack.","This is a reference problem, since we have already deallocated and allocated correctly with regard to reference counts. We should make sure that if something can be reached from the stack and is allocated, that remains unchanged.","fact fix { all s : State | all m : HeapCell | reachFromStack[m,s]}","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B6Zq1CdZ0Y4fTVF4OFRfRjItc3M"
"2017/02/22 7:15:30 PM EST","A HeapCell is deallocated iff the reference count is zero, but from StateA to StateB, we allowed the references to change without checking if the HeapCell was still reachable from the Stack. There is a case in which a HeapCell still has a reference to it, but not reachable from the stack","A HeapCell that has a reference to it must be reachable from the stack","reachFromStack[m, state] iff ref_count[state, m] != 0",""
"2017/02/22 7:15:53 PM EST","B_to_C requires that all cells with at least one reference pointing to them are allocated, but it doesn't require that they be reachable from the Stack, which is what completeness checks for.","Any cell with a reference is reachable from the stack.","reachFromStack[m, s] iff ref_count[s, m] != 0","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0BzbSRUPxbN8xb3lka3hkeFpMaVE"
"2017/02/22 7:24:51 PM EST","Since the reference count of the self-referential loop is 1 at the end in States B/C, it does not count as having a ref_count of 0 and thus it is not allocated.","I would perhaps remove the cell itself from the check for ref_count of a cell.","m not in s.references.m","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B1kzWIO8seVpM3BYX2JoVHBremM"
"2017/02/22 7:25:18 PM EST","There can be references from heap cells to other heap cells, or heap cells to itself that do not allow the heap cells to be removed, even though they are not referenced by the stack.","We need to not have reference cycles that do not include the stack.","m in s.allocated <=> Stack -> m in ^(s.references)","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B9paR5P32gdlNUZ4RTdmOXVZQW8"
"2017/02/22 7:31:25 PM EST","There's always a way for StateA to progress to StateB in such a way that references are removed to allocated memory.","Forcing clean-ness would definitely work, but overconstrains. Another unelegant solution would be to say that Clean[A] implies Clean[B]. ","m in s.allocated implies some (m.(s.reference) & s.allocated)","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B5gneHU6oSjVU1BRZXJQdzZrNTA"
"2017/02/22 7:40:27 PM EST","","","","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0Bw7q6QK9l4w5ZFdfN0dKOTBXZW8"
"2017/02/22 7:49:08 PM EST","We allow references to be self-loops.","If there are no in-going or out-going edges for a node besides its self-reference loop, garbage collect it.","m->m = m <: s.references and m->m = s.references :> m implies m not in s.allocated","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0B88IQieWrPddZkxXUjVxZmhrQmM"
"2017/02/25 9:36:00 PM EST","There is nothing that stipulates that allocated memory must be reachable.","A fact should be added that stipulates that being allocated in a state implies that the state is reachable from that state's Stack.","m in s.allocated implies reachFromStack[m, s]",""
"2017/02/27 2:08:11 AM EST","The problem is that just because the Stack can reach all referenced memory that is allocated in State A does not mean that this is true for State C - the references might be different, so the Stack in C might not be able to reach all referenced memory.","I would make sure that for every memory reference that is reachable by the Stack  in State A, it is also reachable by the Stack in State C","fact fix { all s : State | all m : HeapCell | m in Stack.^(s.references)}","https://drive.google.com/a/brown.edu/open?authuser=0&usp=forms_web&id=0Bz4u-7k6eZfOSkxwVlBVcGhFMUU"